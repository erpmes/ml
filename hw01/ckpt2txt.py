import torchimport torch.nn as nn # Neural Network Modelclass My_Model(nn.Module):    def __init__(self, input_dim):        super(My_Model, self).__init__()        # TODO: modify model's structure, be aware of dimensions.         self.layers = nn.Sequential(            nn.Linear(input_dim, 16),            nn.ReLU(),            nn.Linear(16, 8),            nn.ReLU(),            nn.Linear(8, 1)        )    def forward(self, x):        x = self.layers(x)        x = x.squeeze(1) # (B, 1) -> (B)        return x# 创建模型实例model = My_Model(117)# 加载权重model.load_state_dict(torch.load('./models/model.ckpt'))import json# 假设你的state_dict是一个名为state_dict的字典state_dict = model.state_dict()# 遍历每一层的state_dict，保存到单独的文件中for layer_name, layer_state in state_dict.items():    # 将state_dict中的Tensor对象转换为NumPy数组，然后再转换为Python的内置数据类型    layer_state_python = layer_state.numpy().tolist()    # 将layer_state_python转换为JSON格式的字符串    layer_state_json = json.dumps(layer_state_python)    # 将layer_state_json保存到单独的文件中    file_name = f"{layer_name}.txt"    with open(file_name, 'w') as f:        f.write(layer_state_json)'''# 假设你的state_dict是一个名为state_dict的字典state_dict = model.state_dict()# 将state_dict中的Tensor对象转换为NumPy数组，然后再转换为Python的内置数据类型state_dict_python = {}for key, value in state_dict.items():    state_dict_python[key] = value.numpy().tolist()# 将state_dict_python转换为JSON格式的字符串state_dict_json = json.dumps(state_dict_python)# 将state_dict_json保存到文本文件with open('./state_dict.txt', 'w') as f:    f.write(state_dict_json)''''''# 提取模型权重weights = {}for name, param in model.named_parameters():    weights[name] = param.data.numpy()# 保存权重为txt文件for name, value in weights.items():    with open(f'./{name}.txt', 'w') as f:        f.write('\n'.join(value.flatten().astype(str)))'''