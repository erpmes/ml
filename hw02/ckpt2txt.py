import torchimport torch.nn as nn### Define Modelclass BasicBlock(nn.Module):    def __init__(self, input_dim, output_dim):        super(BasicBlock, self).__init__()        self.block = nn.Sequential(            nn.Linear(input_dim, output_dim),            nn.ReLU(),        )    def forward(self, x):        x = self.block(x)        return xclass Classifier(nn.Module):    def __init__(self, input_dim, output_dim=41, hidden_layers=1, hidden_dim=256):        super(Classifier, self).__init__()        self.fc = nn.Sequential(            BasicBlock(input_dim, hidden_dim),            *[BasicBlock(hidden_dim, hidden_dim) for _ in range(hidden_layers)],            nn.Linear(hidden_dim, output_dim)        )    def forward(self, x):        x = self.fc(x)        return xconcat_nframes = 11# model parametersinput_dim = 39 * concat_nframes # the input dim of the model, you should not change the valuehidden_layers = 1               # the number of hidden layershidden_dim = 256                # the hidden dimdevice = 'cuda:0' if torch.cuda.is_available() else 'cpu'print(f'DEVICE: {device}')# load modelmodel = Classifier(input_dim=input_dim, hidden_layers=hidden_layers, hidden_dim=hidden_dim).to(device)model.load_state_dict(torch.load('./model.ckpt'))import json# 假设你的state_dict是一个名为state_dict的字典state_dict = model.state_dict()# 遍历每一层的state_dict，保存到单独的文件中for layer_name, layer_state in state_dict.items():    # 将state_dict中的Tensor对象转换为NumPy数组，然后再转换为Python的内置数据类型    layer_state_python = layer_state.numpy().tolist()    # 将layer_state_python转换为JSON格式的字符串    layer_state_json = json.dumps(layer_state_python)    # 将layer_state_json保存到单独的文件中    file_name = f"{layer_name}.txt"    with open(file_name, 'w') as f:        f.write(layer_state_json)'''# 假设你的state_dict是一个名为state_dict的字典state_dict = model.state_dict()# 将state_dict中的Tensor对象转换为NumPy数组，然后再转换为Python的内置数据类型state_dict_python = {}for key, value in state_dict.items():    state_dict_python[key] = value.numpy().tolist()# 将state_dict_python转换为JSON格式的字符串state_dict_json = json.dumps(state_dict_python)# 将state_dict_json保存到文本文件with open('./state_dict.txt', 'w') as f:    f.write(state_dict_json)''''''# 提取模型权重weights = {}for name, param in model.named_parameters():    weights[name] = param.data.numpy()# 保存权重为txt文件for name, value in weights.items():    with open(f'./{name}.txt', 'w') as f:        f.write('\n'.join(value.flatten().astype(str)))'''