import torchimport torch.nn as nn### Define Modelclass Classifier(nn.Module):    def __init__(self):        super(Classifier, self).__init__()        # torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride, padding)        # torch.nn.MaxPool2d(kernel_size, stride, padding)        # input 維度 [3, 128, 128]        self.cnn = nn.Sequential(            nn.Conv2d(3, 64, 3, 1, 1),  # [64, 128, 128]            nn.BatchNorm2d(64),            nn.ReLU(),            nn.MaxPool2d(2, 2, 0),      # [64, 64, 64]            nn.Conv2d(64, 128, 3, 1, 1), # [128, 64, 64]            nn.BatchNorm2d(128),            nn.ReLU(),            nn.MaxPool2d(2, 2, 0),      # [128, 32, 32]            nn.Conv2d(128, 256, 3, 1, 1), # [256, 32, 32]            nn.BatchNorm2d(256),            nn.ReLU(),            nn.MaxPool2d(2, 2, 0),      # [256, 16, 16]            nn.Conv2d(256, 512, 3, 1, 1), # [512, 16, 16]            nn.BatchNorm2d(512),            nn.ReLU(),            nn.MaxPool2d(2, 2, 0),       # [512, 8, 8]                        nn.Conv2d(512, 512, 3, 1, 1), # [512, 8, 8]            nn.BatchNorm2d(512),            nn.ReLU(),            nn.MaxPool2d(2, 2, 0),       # [512, 4, 4]        )        self.fc = nn.Sequential(            nn.Linear(512*4*4, 1024),            nn.ReLU(),            nn.Linear(1024, 512),            nn.ReLU(),            nn.Linear(512, 11)        )    def forward(self, x):        out = self.cnn(x)        out = out.view(out.size()[0], -1)        return self.fc(out)    # "cuda" only when GPUs are available.#device = "cuda" if torch.cuda.is_available() else "cpu"device ="cpu"# Initialize a model, and put it on the device specified.model = Classifier().to(device)model.load_state_dict(torch.load('./model.ckpt'))import json# 假设你的state_dict是一个名为state_dict的字典state_dict = model.state_dict()# 遍历每一层的state_dict，保存到单独的文件中for layer_name, layer_state in state_dict.items():    # 将state_dict中的Tensor对象转换为NumPy数组，然后再转换为Python的内置数据类型    layer_state_python = layer_state.numpy().tolist()    # 将layer_state_python转换为JSON格式的字符串    layer_state_json = json.dumps(layer_state_python)    # 将layer_state_json保存到单独的文件中    file_name = f"{layer_name}.txt"    with open(file_name, 'w') as f:        f.write(layer_state_json)'''# 假设你的state_dict是一个名为state_dict的字典state_dict = model.state_dict()# 将state_dict中的Tensor对象转换为NumPy数组，然后再转换为Python的内置数据类型state_dict_python = {}for key, value in state_dict.items():    state_dict_python[key] = value.numpy().tolist()# 将state_dict_python转换为JSON格式的字符串state_dict_json = json.dumps(state_dict_python)# 将state_dict_json保存到文本文件with open('./state_dict.txt', 'w') as f:    f.write(state_dict_json)''''''# 提取模型权重weights = {}for name, param in model.named_parameters():    weights[name] = param.data.numpy()# 保存权重为txt文件for name, value in weights.items():    with open(f'./{name}.txt', 'w') as f:        f.write('\n'.join(value.flatten().astype(str)))'''        