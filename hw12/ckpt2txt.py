import torchimport torch.nn as nnimport torch.nn.functional as F### Define Modelclass Classifier(nn.Module):    def __init__(self):        super().__init__()        self.fc1 = nn.Linear(8, 16)        self.fc2 = nn.Linear(16, 16)        self.fc3 = nn.Linear(16, 4)    def forward(self, state):        hid = torch.tanh(self.fc1(state))        hid = torch.tanh(self.fc2(hid))        return F.softmax(self.fc3(hid), dim=-1)# "cuda" only when GPUs are available.#device = "cuda" if torch.cuda.is_available() else "cpu"device ="cpu"# Initialize a model, and put it on the device specified.model = Classifier().to(device)model.load_state_dict(torch.load('./model.ckpt'))import json# 假设你的state_dict是一个名为state_dict的字典state_dict = model.state_dict()# 遍历每一层的state_dict，保存到单独的文件中for layer_name, layer_state in state_dict.items():    # 将state_dict中的Tensor对象转换为NumPy数组，然后再转换为Python的内置数据类型    layer_state_python = layer_state.numpy().tolist()    # 将layer_state_python转换为JSON格式的字符串    layer_state_json = json.dumps(layer_state_python)    # 将layer_state_json保存到单独的文件中    file_name = f"{layer_name}.txt"    with open(file_name, 'w') as f:        f.write(layer_state_json)'''# 假设你的state_dict是一个名为state_dict的字典state_dict = model.state_dict()# 将state_dict中的Tensor对象转换为NumPy数组，然后再转换为Python的内置数据类型state_dict_python = {}for key, value in state_dict.items():    state_dict_python[key] = value.numpy().tolist()# 将state_dict_python转换为JSON格式的字符串state_dict_json = json.dumps(state_dict_python)# 将state_dict_json保存到文本文件with open('./state_dict.txt', 'w') as f:    f.write(state_dict_json)''''''# 提取模型权重weights = {}for name, param in model.named_parameters():    weights[name] = param.data.numpy()# 保存权重为txt文件for name, value in weights.items():    with open(f'./{name}.txt', 'w') as f:        f.write('\n'.join(value.flatten().astype(str)))'''        